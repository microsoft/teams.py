"""
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the MIT License.

GENERATED FILE - DO NOT EDIT MANUALLY
This file is generated by generate_handlers.py based on activity_config.py
"""

from abc import ABC, abstractmethod
from logging import Logger
from typing import Callable

from microsoft.teams.api.activities import (
    ActivityBase,
    CommandResultActivity,
    CommandSendActivity,
    ConversationUpdateActivity,
    EndOfConversationActivity,
    EventActivity,
    HandoffActivity,
    InstallUpdateActivity,
    InvokeActivity,
    MessageActivity,
    MessageDeleteActivity,
    MessageReactionActivity,
    MessageUpdateActivity,
    TraceActivity,
    TypingActivity,
)

from ..message_handler.activity_context import Context
from ..router import ActivityRouter
from .activity_config import ACTIVITY_ROUTES
from .type_validation import validate_handler_type


class ActivityHandlerMixin(ABC):
    """Mixin class providing typed activity handler registration methods."""

    @property
    @abstractmethod
    def router(self) -> ActivityRouter:
        """The activity router instance. Must be implemented by the concrete class."""
        pass

    @property
    @abstractmethod
    def logger(self) -> Logger:
        """The logger instance used by the app."""
        pass

    def onMessage(self, handler: Callable[[Context[MessageActivity]], None]) -> Callable:
        """Register a message activity handler."""

        def decorator(func: Callable[[Context[MessageActivity]], None]) -> Callable:
            validate_handler_type(self.logger, func, MessageActivity, "onMessage", "MessageActivity")
            config = ACTIVITY_ROUTES["message"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    def onMessageDelete(self, handler: Callable[[Context[MessageDeleteActivity]], None]) -> Callable:
        """Register a messageDelete activity handler."""

        def decorator(func: Callable[[Context[MessageDeleteActivity]], None]) -> Callable:
            validate_handler_type(self.logger, func, MessageDeleteActivity, "onMessageDelete", "MessageDeleteActivity")
            config = ACTIVITY_ROUTES["messageDelete"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    def onMessageReaction(self, handler: Callable[[Context[MessageReactionActivity]], None]) -> Callable:
        """Register a messageReaction activity handler."""

        def decorator(func: Callable[[Context[MessageReactionActivity]], None]) -> Callable:
            validate_handler_type(
                self.logger, func, MessageReactionActivity, "onMessageReaction", "MessageReactionActivity"
            )
            config = ACTIVITY_ROUTES["messageReaction"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    def onMessageUpdate(self, handler: Callable[[Context[MessageUpdateActivity]], None]) -> Callable:
        """Register a messageUpdate activity handler."""

        def decorator(func: Callable[[Context[MessageUpdateActivity]], None]) -> Callable:
            validate_handler_type(self.logger, func, MessageUpdateActivity, "onMessageUpdate", "MessageUpdateActivity")
            config = ACTIVITY_ROUTES["messageUpdate"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    def onCommand(self, handler: Callable[[Context[CommandSendActivity]], None]) -> Callable:
        """Register a command activity handler."""

        def decorator(func: Callable[[Context[CommandSendActivity]], None]) -> Callable:
            validate_handler_type(self.logger, func, CommandSendActivity, "onCommand", "CommandSendActivity")
            config = ACTIVITY_ROUTES["command"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    def onCommandResult(self, handler: Callable[[Context[CommandResultActivity]], None]) -> Callable:
        """Register a commandResult activity handler."""

        def decorator(func: Callable[[Context[CommandResultActivity]], None]) -> Callable:
            validate_handler_type(self.logger, func, CommandResultActivity, "onCommandResult", "CommandResultActivity")
            config = ACTIVITY_ROUTES["commandResult"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    def onConversationUpdate(self, handler: Callable[[Context[ConversationUpdateActivity]], None]) -> Callable:
        """Register a conversationUpdate activity handler."""

        def decorator(func: Callable[[Context[ConversationUpdateActivity]], None]) -> Callable:
            validate_handler_type(
                self.logger, func, ConversationUpdateActivity, "onConversationUpdate", "ConversationUpdateActivity"
            )
            config = ACTIVITY_ROUTES["conversationUpdate"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    def onEndOfConversation(self, handler: Callable[[Context[EndOfConversationActivity]], None]) -> Callable:
        """Register a endOfConversation activity handler."""

        def decorator(func: Callable[[Context[EndOfConversationActivity]], None]) -> Callable:
            validate_handler_type(
                self.logger, func, EndOfConversationActivity, "onEndOfConversation", "EndOfConversationActivity"
            )
            config = ACTIVITY_ROUTES["endOfConversation"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    def onEvent(self, handler: Callable[[Context[EventActivity]], None]) -> Callable:
        """Register a event activity handler."""

        def decorator(func: Callable[[Context[EventActivity]], None]) -> Callable:
            validate_handler_type(self.logger, func, EventActivity, "onEvent", "EventActivity")
            config = ACTIVITY_ROUTES["event"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    def onInvoke(self, handler: Callable[[Context[InvokeActivity]], None]) -> Callable:
        """Register a invoke activity handler."""

        def decorator(func: Callable[[Context[InvokeActivity]], None]) -> Callable:
            validate_handler_type(self.logger, func, InvokeActivity, "onInvoke", "InvokeActivity")
            config = ACTIVITY_ROUTES["invoke"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    def onInstallationUpdate(self, handler: Callable[[Context[InstallUpdateActivity]], None]) -> Callable:
        """Register a installationUpdate activity handler."""

        def decorator(func: Callable[[Context[InstallUpdateActivity]], None]) -> Callable:
            validate_handler_type(
                self.logger, func, InstallUpdateActivity, "onInstallationUpdate", "InstallUpdateActivity"
            )
            config = ACTIVITY_ROUTES["installationUpdate"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    def onTyping(self, handler: Callable[[Context[TypingActivity]], None]) -> Callable:
        """Register a typing activity handler."""

        def decorator(func: Callable[[Context[TypingActivity]], None]) -> Callable:
            validate_handler_type(self.logger, func, TypingActivity, "onTyping", "TypingActivity")
            config = ACTIVITY_ROUTES["typing"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    def onTrace(self, handler: Callable[[Context[TraceActivity]], None]) -> Callable:
        """Register a trace activity handler."""

        def decorator(func: Callable[[Context[TraceActivity]], None]) -> Callable:
            validate_handler_type(self.logger, func, TraceActivity, "onTrace", "TraceActivity")
            config = ACTIVITY_ROUTES["trace"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    def onHandoff(self, handler: Callable[[Context[HandoffActivity]], None]) -> Callable:
        """Register a handoff activity handler."""

        def decorator(func: Callable[[Context[HandoffActivity]], None]) -> Callable:
            validate_handler_type(self.logger, func, HandoffActivity, "onHandoff", "HandoffActivity")
            config = ACTIVITY_ROUTES["handoff"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator

    def onActivity(self, handler: Callable[[Context[ActivityBase]], None]) -> Callable:
        """Register a activity activity handler."""

        def decorator(func: Callable[[Context[ActivityBase]], None]) -> Callable:
            validate_handler_type(self.logger, func, ActivityBase, "onActivity", "ActivityBase")
            config = ACTIVITY_ROUTES["activity"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator
