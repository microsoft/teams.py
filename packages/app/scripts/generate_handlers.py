"""
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the MIT License.
"""

import subprocess
import sys
from pathlib import Path

sys.path.append("..")

from src.microsoft.teams.app.message_handler.activity_config import ACTIVITY_ROUTES, ActivityConfig


def generate_imports() -> str:
    """Generate import statements for the generated file."""
    imports = {
        "from abc import ABC, abstractmethod",
        "from typing import Callable, Optional, Union",
        "from ..context import Context",
        "from ..router import ActivityRouter",
        "from .type_validation import validate_handler_type",
        "from microsoft.teams.api.activities import ActivityBase",
        "from logging import Logger",
    }

    # Add imports for each activity class
    for config in ACTIVITY_ROUTES:
        class_name = config.input_model.__name__
        if class_name == "Annotated":
            class_name = config.type_name  # use explicit type_name if provided
        imports.add(f"from microsoft.teams.api.activities import {class_name}")

    return "\n".join(sorted(imports))


def generate_method(config: ActivityConfig) -> str:
    """Generate a single handler method with strict typing and runtime validation."""
    method_name = config.method_name
    activity_name = config.name

    # Use the explicit type_name if provided, otherwise fall back to __name__
    input_class_name = config.type_name or config.input_model.__name__

    # Determine output type
    if config.output_model:
        output_type = f"Optional[{config.output_model.__name__}]"
    else:
        output_type = "Optional[dict]"

    return f'''    def {method_name}(self, handler: Callable[[Context[{input_class_name}]], {output_type}]) -> Callable:
        """Register a {activity_name} activity handler."""
        def decorator(func: Callable[[Context[{input_class_name}]], {output_type}]) -> Callable:
            validate_handler_type(self.logger, func, {input_class_name}, "{method_name}", "{input_class_name}")
            self.router.add_handler("{activity_name}", func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator'''


def generate_mixin_class() -> str:
    """Generate the complete ActivityHandlerMixin class."""
    methods = []

    for config in ACTIVITY_ROUTES:
        methods.append(generate_method(config))

    methods_code = "\n\n".join(methods)

    return f'''class ActivityHandlerMixin(ABC):
    """Mixin class providing typed activity handler registration methods."""

    @property
    @abstractmethod
    def router(self) -> ActivityRouter:
        """The activity router instance. Must be implemented by the concrete class."""
        pass

    @property
    @abstractmethod
    def logger(self) -> Logger:
        """The logger instance used by the app."""
        pass

{methods_code}'''


def generate_file_header() -> str:
    """Generate the file header with copyright and description."""
    return '''"""
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the MIT License.

GENERATED FILE - DO NOT EDIT MANUALLY
This file is generated by generate_handlers.py based on activity_config.py
"""'''


def generate_activity_handlers():
    """Generate the complete activity handlers file."""
    print("üîß Generating activity handlers...")

    # Build the complete file content
    content_parts = [
        generate_file_header(),
        "",
        generate_imports(),
        "",
        "",
        generate_mixin_class(),
    ]

    generated_code = "\n".join(content_parts)

    # Write to the message_handler directory in the source code
    # Use Path(__file__) to find this script's location, then navigate to the target
    script_dir = Path(__file__).parent
    source_dir = script_dir.parent / "src" / "microsoft" / "teams" / "app" / "message_handler"
    output_path = source_dir / "generated_handlers.py"

    # Ensure the target directory exists
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(generated_code)

    print(f"‚úÖ Generated {len(ACTIVITY_ROUTES)} activity handlers in {output_path}")
    print("üìù Generated methods:")
    for config in ACTIVITY_ROUTES:
        print(f"   - {config.method_name}() for {config.name} activities")

    # execute poe fmt on the generated file
    subprocess.run(["poe", "lint", "--select", "I", "--select", "F401", "--fix"], check=True)
    subprocess.run(["poe", "fmt", str(output_path)], check=True)


if __name__ == "__main__":
    generate_activity_handlers()
