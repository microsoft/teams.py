"""
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the MIT License.
"""

import subprocess
import sys
from pathlib import Path

# Add paths for dependencies
app_dir = Path(__file__).parent.parent
api_dir = app_dir.parent / "api" / "src"
sys.path.insert(0, str(app_dir / "src"))
sys.path.insert(0, str(api_dir))

# Import the activity config directly without going through the package hierarchy
activity_config_path = app_dir / "src" / "microsoft" / "teams" / "app" / "message_handler" / "activity_config.py"

# Load the activity config module directly
import importlib.util

spec = importlib.util.spec_from_file_location("activity_config", activity_config_path)
activity_config = importlib.util.module_from_spec(spec)
spec.loader.exec_module(activity_config)

ACTIVITY_ROUTES = activity_config.ACTIVITY_ROUTES
ActivityConfig = activity_config.ActivityConfig


def generate_imports() -> str:
    """Generate import statements for the generated file."""
    imports = {
        "from abc import ABC, abstractmethod",
        "from typing import Callable, Optional, Union",
        "from .activity_context import Context",
        "from ..router import ActivityRouter",
        "from .type_validation import validate_handler_type",
        "from .activity_config import ACTIVITY_ROUTES",
        "from microsoft.teams.api import ActivityBase",
        "from logging import Logger",
    }

    # Add imports for each activity class
    for config in ACTIVITY_ROUTES.values():
        # Use explicit input_type_name if provided, otherwise fall back to __name__
        class_name = config.input_type_name or config.input_model.__name__
        imports.add(f"from microsoft.teams.api.activities import {class_name}")
        if config.output_model:
            # Use explicit output_type_name if provided, otherwise fall back to __name__
            output_class_name = config.output_type_name or config.output_model.__name__
            imports.add(f"from microsoft.teams.api.models.invoke_response import {output_class_name}")

    return "\n".join(sorted(imports))


def generate_method(config: ActivityConfig, config_key: str) -> str:
    """Generate a single handler method with strict typing and runtime validation."""
    method_name = config.method_name
    activity_name = config.name

    # Use the explicit input_type_name if provided, otherwise fall back to __name__
    input_class_name = config.input_type_name or config.input_model.__name__

    # Determine output type
    if config.output_model:
        # Use explicit output_type_name if provided, otherwise fall back to __name__
        output_class_name = config.output_type_name or config.output_model.__name__
        output_type = f"Optional[{output_class_name}]"
    else:
        output_type = "None"

    return f'''    def {method_name}(self, handler: Callable[[Context[{input_class_name}]], {output_type}]) -> Callable:
        """Register a {activity_name} activity handler."""
        def decorator(func: Callable[[Context[{input_class_name}]], {output_type}]) -> Callable:
            validate_handler_type(self.logger, func, {input_class_name}, "{method_name}", "{input_class_name}")
            config = ACTIVITY_ROUTES["{config_key}"]
            self.router.add_handler(config.selector, func)
            return func

        if handler is not None:
            return decorator(handler)
        return decorator'''


def generate_mixin_class() -> str:
    """Generate the complete ActivityHandlerMixin class."""
    methods = []

    for config_key, config in ACTIVITY_ROUTES.items():
        methods.append(generate_method(config, config_key))

    methods_code = "\n\n".join(methods)

    return f'''class ActivityHandlerMixin(ABC):
    """Mixin class providing typed activity handler registration methods."""

    @property
    @abstractmethod
    def router(self) -> ActivityRouter:
        """The activity router instance. Must be implemented by the concrete class."""
        pass

    @property
    @abstractmethod
    def logger(self) -> Logger:
        """The logger instance used by the app."""
        pass

{methods_code}'''


def generate_file_header() -> str:
    """Generate the file header with copyright and description."""
    return '''"""
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the MIT License.

GENERATED FILE - DO NOT EDIT MANUALLY
This file is generated by generate_handlers.py based on activity_config.py
"""'''


def generate_activity_handlers():
    """Generate the complete activity handlers file."""
    print("üîß Generating activity handlers...")

    # Build the complete file content
    content_parts = [
        generate_file_header(),
        "",
        generate_imports(),
        "",
        "",
        generate_mixin_class(),
    ]

    generated_code = "\n".join(content_parts)

    # Write to the message_handler directory in the source code
    # Use Path(__file__) to find this script's location, then navigate to the target
    script_dir = Path(__file__).parent
    source_dir = script_dir.parent / "src" / "microsoft" / "teams" / "app" / "message_handler"
    output_path = source_dir / "generated_handlers.py"

    # Ensure the target directory exists
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(generated_code)

    print(f"‚úÖ Generated {len(ACTIVITY_ROUTES)} activity handlers in {output_path}")
    print("üìù Generated methods:")
    for config in ACTIVITY_ROUTES.values():
        print(f"   - {config.method_name}() for {config.name} activities")

    # execute poe fmt on the generated file
    subprocess.run(["poe", "lint", "--select", "I", "--select", "F401", "--fix"], check=True)
    subprocess.run(["poe", "fmt", str(output_path)], check=True)


if __name__ == "__main__":
    generate_activity_handlers()
